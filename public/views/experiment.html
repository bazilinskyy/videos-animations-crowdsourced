<!doctype html>
<html>
  <head>
    <title>Experiment page</title>
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'></script>
    <script src='jsPsych/jspsych.js'></script>
    <script src='jsPsych/plugins/jspsych-html-keyboard-response.js'></script>
    <script src='jsPsych/plugins/jspsych-video-keyboard-multiple-responses-release.js'></script>
    <script src='jsPsych/plugins/jspsych-html-slider-response.js'></script>
    <script src='jsPsych/plugins/jspsych-survey-multi-choice.js'></script>
    <script src='jsPsych/plugins/jspsych-call-function.js'></script>
    <link href='jsPsych/css/jspsych.css' rel='stylesheet' type='text/css'></link>
    <link href='css/experiment.css' rel='stylesheet' type='text/css'></link>
    <link rel='icon' type='image/png' href='/img/favicon.png' />
  </head>
  <body>
  </body>
  <script>
// by Pavlo Bazilinskyy <p.bazilinskyy@tudelft.nl>

// Constants
var n_videos = 28; // number of videos
var n_repeat = 2; // number of repeats of each condition
var n_videos_per_block = 4; // number of videos in each block
var n_break = 10; // number of videos between each break
var video_prefix = 'videos/video_'; // prefix for videos
var image_pfefix = 'img/'; // prefix for images
var SHOW_DEBUG = false; // switch for debugging output

/**
* Returns a random integer between min (inclusive) and max (inclusive).
* The value is no lower than min (or the next integer greater than min
* if min isn't an integer) and no greater than max (or the next integer
* lower than max if max isn't an integer).
* Using Math.round() will give you a non-uniform distribution!
*/
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Get finish code for the worker.
 */
function getFinishCode() {
    var timestamp = window.performance.timing.navigationStart + window.performance.now();
    var current_time = Math.round(timestamp);
    var random_num = getRandomInt(1, 10000);
    finish_code = 'Q6' + current_time + 'BV' + random_num + '2M';
    return finish_code;
}

var finish_code = getFinishCode();

/**
 * Shuffles array in place.
 * @param {Array} a items An array containing the items.
 */
function shuffle(a) {
    var j, x, i;
    for (i = a.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = a[i];
        a[i] = a[j];
        a[j] = x;
    }
    return a;
}

/**
 * Get parameter from URL.
 */
var getUrlParameter = function getUrlParameter(sParam) {
    var sPageURL = decodeURIComponent(window.location.search.substring(1)),
        sURLVariables = sPageURL.split('&'),
        sParameterName,
        i;
    for (i = 0; i < sURLVariables.length; i++) {
        sParameterName = sURLVariables[i].split('=');
        if (sParameterName[0] === sParam) {
            return sParameterName[1] === undefined ? true : sParameterName[1];
        }
    }
};

var group_choice = getRandomInt(0, 3);

// try to get status of debugging from URL
var debug = getUrlParameter('debug');
if (!debug) {
    debug = SHOW_DEBUG;
}

// Arrays for storing data
var video_ids_1 = [];  // IDs of videos in stimuli in 1st part
var video_ids_2 = [];  // IDs of videos in stimuli in 2nd part
var between_blocks = []; // instructions between blocks
var video_stimuli = []; // blocks with videos

// group 1
// create array of video_ids, remove 0th id, shuffle
var videos_n_1 = 28; // number of videos + 1
var video_ids_1 = [];
for (var i = 1; i <= videos_n_1; i++) {
    for (var j = 0; j < n_repeat; j++) {
        video_ids_1.push(i);
    }
}
video_ids_1 = shuffle(video_ids_1);

// group 2
var videos_n_2 = 56; // number of videos + 1  
var video_ids_2 = [];
for (var i = 29; i <= videos_n_2; i++) {
    for (var j = 0; j < n_repeat; j++) {
        video_ids_2.push(i);
    }
}
video_ids_2 = shuffle(video_ids_2);

if (group_choice == 0) {  // group 1 with instructions (videos 1-28)
    video_ids = video_ids_1;
    stimulus_str = '<p>The purpose of this experiment is to determine if the movement of an automated vehicle can be used to communicate if it is going to stop for a pedestrian. In the following videos, you will see an automated vehicle deviate within its lane as it approaches you. The direction of the deviation indicates whether it intends to stop or keep going. Your task will be to hold a response key if you feel safe to cross.</p><p>You will view ' + n_videos * n_repeat + ' animations. Press and HOLD \'F\' when you feel safe to cross the road in front of the car. You can release the button and then press it again as many times as you want during the video. After each ' + n_break + ' videos you will be able to take a small break. The window of your browser should be at least 1300px wide and 800px tall. Press \'C\' to start the first video.</p>';
    question_prompt = "In the current study, the car went <strong>towards you when stopping, and away from you when it continued driving</strong>. Do you prefer this mapping, or would you prefer the opposite mapping: <strong>away from you when stopping, and towards you when it continued driving</strong>? Select your answer:";
    question_options = ["I prefer the mapping <strong>towards me when stopping, and away from me when the car continues driving</strong>", "I prefer the mapping <strong>away from me when stopping, and towards me when the car continues driving</strong>"];
} else if (group_choice == 1)  { // group 2 with no instructions (videos 1-28)
    video_ids = video_ids_1;
    stimulus_str = '<p>The purpose of this experiment is to determine your willingness to cross in front of an automated vehicle. In the following videos, you will see an automated vehicle approaching you.</p><p>You will view ' + n_videos * n_repeat + ' animations. Press and HOLD \'F\' when you feel safe to cross the road in front of the car. You can release the button and then press it again as many times as you want during the video. After each ' + n_break + ' videos you will be able to take a small break. The window of your browser should be at least 1300px wide and 800px tall. Press \'C\' to start the first video.</p>';
    question_prompt = "In the current study, the car went <strong>towards you when stopping, and away from you when it continued driving</strong>. Do you prefer this mapping, or would you prefer the opposite mapping: <strong>away from you when stopping, and towards you when it continued driving</strong>? Select your answer:";
    question_options = ["I prefer the mapping <strong>towards me when stopping, and away from me when the car continues driving</strong>", "I prefer the mapping <strong>away from me when stopping, and towards me when the car continues driving</strong>"];
} else if (group_choice == 2)  { // group 3 with instructions (videos 29-56)
    video_ids = video_ids_2;
    stimulus_str = '<p>The purpose of this experiment is to determine if the movement of an automated vehicle can be used to communicate if it is going to stop for a pedestrian. In the following videos, you will see an automated vehicle deviate within its lane as it approaches you. The direction of the deviation indicates whether it intends to stop or keep going. Your task will be to hold a response key if you feel safe to cross.</p><p>You will view ' + n_videos * n_repeat + ' animations. Press and HOLD \'F\' when you feel safe to cross the road in front of the car. You can release the button and then press it again as many times as you want during the video. After each ' + n_break + ' videos you will be able to take a small break. The window of your browser should be at least 1300px wide and 800px tall. Press \'C\' to start the first video.</p>';
    question_prompt = "In the current study, the car went <strong>away from you when stopping, and towards you when it continued driving</strong>. Do you prefer this mapping, or would you prefer the opposite mapping: <strong>towards you when stopping, and away from you when it continued driving</strong>? Select your answer:";
    question_options = ["I prefer the mapping <strong>away from me when stopping, and towards me when the car continues driving</strong>", "I prefer the mapping <strong>towards me when stopping, and away from me when the car continues driving</strong>"];
} else if (group_choice == 3)  { // group 4 with no instructions (videos 29-56)
    video_ids = video_ids_2;
    stimulus_str = '<p>The purpose of this experiment is to determine your willingness to cross in front of an automated vehicle. In the following videos, you will see an automated vehicle approaching you.</p><p>You will view ' + n_videos * n_repeat + ' animations. Press and HOLD \'F\' when you feel safe to cross the road in front of the car. You can release the button and then press it again as many times as you want during the video. After each ' + n_break + ' videos you will be able to take a small break. The window of your browser should be at least 1300px wide and 800px tall. Press \'C\' to start the first video.</p>';
    question_prompt = "In the current study, the car went <strong>away from you when stopping, and towards you when it continued driving</strong>. Do you prefer this mapping, or would you prefer the opposite mapping: <strong>towards you when stopping, and away from you when it continued driving</strong>? Select your answer:";
    question_options = ["I prefer the mapping <strong>away from me when stopping, and towards me when the car continues driving</strong>", "I prefer the mapping <strong>towards me when stopping, and away from me when the car continues driving</strong>"];
}

// browser info
// https://stackoverflow.com/questions/11219582/how-to-detect-my-browser-version-and-operating-system-using-javascript
var nVer = navigator.appVersion;
var nAgt = navigator.userAgent;
var br_name  = navigator.appName;
var br_full_version  = ''+parseFloat(navigator.appVersion); 
var br_major_version = parseInt(navigator.appVersion,10);
var nameOffset,verOffset,ix;

// In Opera, the true version is after "Opera" or after "Version"
if ((verOffset=nAgt.indexOf("Opera"))!=-1) {
 br_name = "Opera";
 br_full_version = nAgt.substring(verOffset+6);
 if ((verOffset=nAgt.indexOf("Version"))!=-1) 
   br_full_version = nAgt.substring(verOffset+8);
}
// In MSIE, the true version is after "MSIE" in userAgent
else if ((verOffset=nAgt.indexOf("MSIE"))!=-1) {
 br_name = "Microsoft Internet Explorer";
 br_full_version = nAgt.substring(verOffset+5);
}
// In Chrome, the true version is after "Chrome" 
else if ((verOffset=nAgt.indexOf("Chrome"))!=-1) {
 br_name = "Chrome";
 br_full_version = nAgt.substring(verOffset+7);
}
// In Safari, the true version is after "Safari" or after "Version" 
else if ((verOffset=nAgt.indexOf("Safari"))!=-1) {
 br_name = "Safari";
 br_full_version = nAgt.substring(verOffset+7);
 if ((verOffset=nAgt.indexOf("Version"))!=-1) 
   br_full_version = nAgt.substring(verOffset+8);
}
// In Firefox, the true version is after "Firefox" 
else if ((verOffset=nAgt.indexOf("Firefox"))!=-1) {
 browserName = "Firefox";
 br_full_version = nAgt.substring(verOffset+8);
}
// In most other browsers, "name/version" is at the end of userAgent 
else if ( (nameOffset=nAgt.lastIndexOf(' ')+1) < 
          (verOffset=nAgt.lastIndexOf('/')) ) 
{
 browserName = nAgt.substring(nameOffset,verOffset);
 br_full_version = nAgt.substring(verOffset+1);
 if (browserName.toLowerCase()==browserName.toUpperCase()) {
  browserName = navigator.appName;
 }
}
// trim the br_full_version string at semicolon/space if present
if ((ix=br_full_version.indexOf(";"))!=-1)
   br_full_version=br_full_version.substring(0,ix);
if ((ix=br_full_version.indexOf(" "))!=-1)
   br_full_version=br_full_version.substring(0,ix);

br_major_version = parseInt(''+br_full_version,10);
if (isNaN(br_major_version)) {
 br_full_version  = ''+parseFloat(navigator.appVersion); 
 br_major_version = parseInt(navigator.appVersion,10);
}

if (debug) {
    console.log('browser name', br_name);
    console.log('browser full version', br_full_version);
    console.log('browser major version', br_major_version);
    console.log('browser navigator.appName', navigator.appName);
    console.log('browser navigator.userAgent', navigator.userAgent);
}

// define instructions block
var instructions_block = {
    type: 'html-keyboard-response',
    stimulus: stimulus_str,
    choices: ['C'],
    on_finish: function(data) {
        jsPsych.data.addDataToLastTrial({
            worker_code: finish_code,
            browser_name: br_name,
            browser_full_version: br_full_version,
            browser_major_version: br_major_version,
            browser_app_name: navigator.appName,
            browser_user_agent: navigator.userAgent
        });
    }
};

// build array with videos with stimuli
for (var i = 0; i < n_videos * n_repeat; i++) {
    if (debug) {
        console.log(i, video_prefix + video_ids[i] + '.mp4');
    }
    video_stimuli.push({
        type: 'video-keyboard-multiple-responses-release',
        autoplay: true,
        controls: false,
        width: 1280,
        height: 720,
        choices: ['F'],
        sources: [video_prefix + video_ids[i] + '.mp4'],
        prompt: '<p>Start by <strong>HOLDING</strong> the \'F\' key. Release the key when it becomes unsafe to cross; press again when safe to cross.</p>',
        on_finish: function(data) {
            jsPsych.data.addDataToLastTrial({
                worker_code: finish_code
            });
        }
    });
}
// block with text question in the end of the study
var question_block = {
    type: 'survey-multi-choice',
    questions: [
      {prompt: question_prompt, options: question_options, required: true}
    ],
};
// block with slider for each video
var slider_block = {
    type: 'html-slider-response',
    labels: ['0', '20', '40', '60', '80', '100'],
    stimulus: "<p style='width: 1000px'>Please rate the following statement: The behaviour of the car in the previous video was intuitive for signaling that <strong>the car stopped or did not stop</strong> (0 = completely disagree, 100 = completely agree)</p>",
    slider_width: 1000,
    prompt: "",
    require_movement: true
};
// build between blocks
for (var i = 1; i <= n_videos * n_repeat / n_break; i++) {
    var videos_done = n_break * i;
    between_blocks.push({
        type: 'html-keyboard-response',
        stimulus: '<p>You have now completed ' + videos_done + ' videos out of ' + n_videos * n_repeat + '. When ready press \'C\' to proceed to the next batch.</p>',
        choices: ['C']
    });
}
// continue before showing the image
var continue_block = {
    type: 'html-keyboard-response',
    stimulus: '<p>Press \'C\' to continue to the next video.</p>',
    choices: ['C']
};
// black with image to be added before each video
var image_block = {
    type: 'html-keyboard-response',
    stimulus: '<img src=\'' + image_pfefix + 'black_frame.png\'/><p>Start by <strong>HOLDING</strong> the \'F\' key. Release the key when it becomes unsafe to cross; press again when safe to cross.</p>',
    choices: ['F'],
};
// block for sending data
var save_data_block = {
    type: 'call-function',
    func: function() {
        $.ajax({
                type: 'POST',
                url: '/experiment-data',
                data: jsPsych.data.get().json(),
                contentType: 'application/json'
            })
            .done(function() {
                jsPsych.data.reset();
            })
            .fail(function() {
                alert('A problem occurred while writing to the database. Please contact the researcher for more information.')
                window.location.href = '/';
            })
    }
}
// create experiment timeline array
var timeline = [];
timeline.push(question_block);
timeline.push(instructions_block);
// iterate over images
var between_blocks_count = 0;  // counter of shown between blocks
for (var i = 0; i <= n_videos * n_videos_per_block; i++) {
    // check if the last image was reached
    if (i >= n_videos * n_repeat) {
        break;
    }
    // add the continue page before all images except for the 1st one
    if (i != 0 && (i + 1) % n_break != 1) {
        timeline.push(continue_block);
    }
    timeline.push(image_block);  // page with an image asking to press the key
    timeline.push(video_stimuli[i]);  // page with the stimulus
    timeline.push(slider_block);
    if (debug) {
        console.log(i, video_stimuli[i]);
    }
    // question in the end
    if (i == n_videos * n_repeat - 1) {
        if (debug) {
            console.log('added radio question', i);
        }
        timeline.push(question_block);
    }
    // save data
    if ((i + 1) % n_videos_per_block == 0) {
        timeline.push(save_data_block);
    }
    // don't add the between block after the last trial
    if ((i + 1) % n_break == 0 && i != 0) {
        if (debug) {
            console.log('added break', i, between_blocks[between_blocks_count]);
        }
        timeline.push(between_blocks[between_blocks_count]);
        between_blocks_count++;
    }
}

if (debug) {
    console.log('finish_code', finish_code);
    console.log('stimulus_str (instructions)', stimulus_str);
    console.log('question_prompt (last question)', question_prompt);
    console.log('question_options (last question)', question_options);
    console.log('group_choice', group_choice);
    console.log('video_ids_1', video_ids_1);
    console.log('video_ids_2', video_ids_2);
    console.log('between_blocks', between_blocks);
    console.log('video_stimuli', video_stimuli);
    console.log('timeline', timeline);
}

/* Start the experiment */
jsPsych.init({
  // auto_preload: false,
    show_preload_progress_bar: true,
    preload_images: [image_pfefix + 'black_frame.png'],
    timeline: timeline,
    max_load_time: 3000000,
    on_finish: function() {
        window.location.href = 'finish?work=' + finish_code;
    }
});
</script>
</html>
